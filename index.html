<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Location-Based YouTube Video Playback</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <link href="https://unpkg.com/maplibre-gl/dist/maplibre-gl.css" rel="stylesheet" />
    <style>
      body { 
        font-family: Arial, sans-serif; 
        margin: 0;
        padding: 0;
      }
      
      /* Common styling for all intro pages */
      .intro-page {
        text-align: center;
        padding: 50px 20px;
        max-width: 800px;
        margin: 0 auto;
      }
      
      .intro-page h1 {
        font-size: 28px;
        margin-bottom: 30px;
        line-height: 1.4;
      }
      
      .intro-page h2 {
        font-size: 24px;
        margin-bottom: 30px;
        line-height: 1.4;
      }
      
      .intro-page p {
        font-size: 18px;
        margin-bottom: 40px;
        line-height: 1.6;
      }
      
      /* Button styling */
      .intro-page button,
      .languageButton {
        padding: 15px 40px;
        font-size: 18px;
        cursor: pointer;
        border: 2px solid #333;
        background-color: #fff;
        color: #333;
        border-radius: 5px;
        transition: all 0.3s ease;
        min-width: 200px;
        margin: 10px;
      }
      
      .intro-page button:hover,
      .languageButton:hover {
        background-color: #333;
        color: #fff;
      }
      
      .languageButton {
        font-size: 20px;
        min-width: 220px;
      }
      
      #map { height: 400px; width: 100%; }
      #videoContainer { margin-top: 20px; display: none}
      #player { width: 100%; height: 315px; } /* Adjust for YouTube IFrame player */
      #distanceInfo { margin-top: 20px; }
      #debugInfo { margin-top: 10px; padding: 10px; background-color: #f0f0f0; border: 1px solid #ccc; font-family: monospace; }
      #version { position: fixed; top: 10px; right: 10px; background-color: rgba(0,0,0,0.7); color: white; padding: 5px 10px; border-radius: 3px; font-size: 12px; z-index: 1000; }
      .hidden { display: none; }
    </style>
  </head>
  <body>
    <div id="version">v1.0.10 - 2025-11-20</div>
    <div id="languagePage" class="intro-page">
      <div>
        <button class="languageButton" data-lang="en">English</button>
        <button class="languageButton" data-lang="de">Deutsch</button>
      </div>
    </div>
    
    <div id="fullscreenPage" class="intro-page hidden">
      <h1 data-i18n="fullscreenTitle">Location-Based YouTube Video Experience</h1>
      <p data-i18n="fullscreenDescription">For the best experience, we recommend using fullscreen mode.</p>
      <button id="enterFullscreen" data-i18n="fullscreenButton">Enter Fullscreen & Start</button>
    </div>
    
    <div id="infoPage" class="intro-page hidden">
      <h1 data-i18n="infoTitle">Welcome to the Location-Based YouTube Video Experience</h1>
      <p data-i18n="infoDescription">This page will guide you through an interactive location-based video experience.</p>
      <button id="nextToConsent" data-i18n="nextButton">Next</button>
    </div>

    <div id="consentPage" class="intro-page hidden">
      <h2 data-i18n="consentTitle">We need your consent for location tracking</h2>
      <button id="acceptConsent" data-i18n="consentButton">Accept and Continue</button>
    </div>

    <div id="mapPage" class="hidden">
      <div id="map"></div>
      <div id="videoContainer">
        <div id="player"></div> <!-- YouTube IFrame API will replace this div with the video player -->
      </div>
      <div id="distanceInfo"></div>
      <div id="debugInfo">Location updates: <span id="updateCounter">0</span></div>
    </div>

    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://unpkg.com/maplibre-gl/dist/maplibre-gl.js"></script>
    <script src="https://unpkg.com/@maplibre/maplibre-gl-leaflet/leaflet-maplibre-gl.js"></script>
    <script src="https://www.youtube.com/iframe_api"></script> <!-- YouTube IFrame API -->
    <script>

      // 0. This code loads the IFrame Player API code asynchronously.
      var tag = document.createElement('script');

      tag.src = "https://www.youtube.com/iframe_api";
      var firstScriptTag = document.getElementsByTagName('script')[0];
      firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

      // rest of code

      // Translations
      const translations = {
        en: {
          fullscreenTitle: "VideoWalk Experience",
          fullscreenDescription: "For the best experience, we recommend using fullscreen mode.",
          fullscreenButton: "Enter Fullscreen & Start",
          infoTitle: "Welcome to the VideoWalk Experience",
          infoDescription: "This page will guide you through an interactive location-based video experience.",
          nextButton: "Next",
          consentTitle: "We need your consent for location tracking",
          consentButton: "Accept and Continue",
          mapTitle: "Your Current Location",
          distanceText: "You are {distance} meters away from the closest location. Head {direction}.",
          locationUpdates: "Location updates:"
        },
        de: {
          fullscreenTitle: "VideoWalk Erlebnis",
          fullscreenDescription: "Für das beste Erlebnis empfehlen wir den Vollbildmodus.",
          fullscreenButton: "Vollbild aktivieren & Starten",
          infoTitle: "Willkommen beim VideoWalk Erlebnis",
          infoDescription: "Diese Seite führt Sie durch ein interaktives standortbasiertes Video-Erlebnis.",
          nextButton: "Weiter",
          consentTitle: "Wir benötigen Ihre Zustimmung zur Standortverfolgung",
          consentButton: "Akzeptieren und Fortfahren",
          mapTitle: "Ihr aktueller Standort",
          distanceText: "Sie sind {distance} Meter vom nächsten Standort entfernt. Gehen Sie nach {direction}.",
          locationUpdates: "Standort-Updates:"
        }
      };

      let selectedLanguage = 'en';

      let videosData = [];
      let videoCircles = []; // Store circles to update popups when language changes
      let map, userMarker, player;
      let videoToLoad = null; // Used to queue video loading if player isn't ready
      let isPlayerReady = false; // Flag to track player readiness
      let watchId = null; // Store the watch ID
      let locationUpdateCount = 0; // Counter for location updates
      let hasInitiallycentered = false; // Flag to track if map has been centered on first location
      let isVideoPlaying = false; // Flag to track if video is currently playing

      const languagePage = document.getElementById('languagePage');
      const languageButtons = document.querySelectorAll('.languageButton');
      const enterFullscreenButton = document.getElementById('enterFullscreen');
      const fullscreenPage = document.getElementById('fullscreenPage');
      const nextButton = document.getElementById('nextToConsent');
      const acceptButton = document.getElementById('acceptConsent');
      const infoPage = document.getElementById('infoPage');
      const consentPage = document.getElementById('consentPage');
      const mapPage = document.getElementById('mapPage');
      const videoElement = document.getElementById('locationVideo');
      const distanceInfo = document.getElementById('distanceInfo');

      // Translation function
      function t(key) {
        return translations[selectedLanguage][key] || key;
      }

      // Update all translatable elements
      function updateLanguage() {
        document.querySelectorAll('[data-i18n]').forEach(element => {
          const key = element.getAttribute('data-i18n');
          element.textContent = t(key);
        });
        // Update debug info label
        const debugLabel = document.querySelector('#debugInfo');
        if (debugLabel) {
          debugLabel.innerHTML = t('locationUpdates') + ' <span id="updateCounter">' + locationUpdateCount + '</span>';
        }
        // Update popup content for existing circles
        updatePopupContent();
      }

      // Update popup content based on selected language
      function updatePopupContent() {
        videoCircles.forEach(circleData => {
          const { circle, video } = circleData;
          const { title, description } = video;
          const videoTitle = typeof title === 'object' ? (title[selectedLanguage] || title.en) : title;
          const videoDescription = typeof description === 'object' ? (description[selectedLanguage] || description.en) : description;
          
          if (videoTitle || videoDescription) {
            let popupContent = '';
            if (videoTitle) {
              popupContent += `<strong>${videoTitle}</strong>`;
            }
            if (videoDescription) {
              popupContent += videoTitle ? `<br>${videoDescription}` : videoDescription;
            }
            circle.setPopupContent(popupContent);
          }
        });
      }

      const PLAYER_UNSTARTED = -1;
      const PLAYER_ENDED = 0;
      const PLAYER_PLAYING = 1;
      const PLAYER_PAUSED = 2;
      const PLAYER_BUFFERING = 3;

      // Step -1: Language Selection
      languageButtons.forEach(button => {
        button.addEventListener('click', () => {
          selectedLanguage = button.getAttribute('data-lang');
          updateLanguage();
          languagePage.classList.add('hidden');
          fullscreenPage.classList.remove('hidden');
        });
      });

      // Step 0: Enter Fullscreen and transition to Info Page
      enterFullscreenButton.addEventListener('click', () => {
        const elem = document.documentElement;
        if (elem.requestFullscreen) {
          elem.requestFullscreen().catch(err => {
            console.log('Fullscreen request failed:', err);
            // Continue to next page even if fullscreen fails
            fullscreenPage.classList.add('hidden');
            infoPage.classList.remove('hidden');
          });
        }
        // Transition to info page
        fullscreenPage.classList.add('hidden');
        infoPage.classList.remove('hidden');
      });

      // Step 1: Transition from Info Page to Consent Page
      nextButton.addEventListener('click', () => {
        infoPage.classList.add('hidden');
        consentPage.classList.remove('hidden');
      });

      // Step 2: Consent to Geolocation and Initialize Map
      acceptButton.addEventListener('click', () => {
        consentPage.classList.add('hidden');
        mapPage.classList.remove('hidden');
        initMap(); // Initialize the map first
        fetchVideoLocations(); // Fetch video locations only after map is initialized
      });

      // Step 3: Initialize OpenStreetMap
      function initMap() {
        map = L.map('map').setView([51.505, -0.09], 13); // Default view before getting the user's location

        L.maplibreGL({
          style: 'https://tiles.openfreemap.org/styles/positron'
        }).addTo(map);

        getUserLocation(); // Start tracking the user's location once the map is initialized
      }

      /***************************/
      /**                       **/
      /**    GEOLOCATION API    **/
      /**                       **/

      // Step 4: Get the user's location with continuous 5-second updates
      function getUserLocation() {
        if (navigator.geolocation) {
          // Use watchPosition for continuous location updates
          watchId = navigator.geolocation.watchPosition(
            success, 
            error, 
            {
              enableHighAccuracy: true, // enable high accuracy
              timeout: 10000, // wait for 10 seconds
              maximumAge: 0 // don't use cached position
            }
          );
          
          // Set up 5-second interval to request fresh location
          setInterval(() => {
            if (watchId !== null) {
              // watchPosition will automatically trigger success callback
              console.log('Location update requested (5-second interval)');
            }
          }, 5000);
        } else {
          alert('Geolocation is not supported by your browser.');
        }
        
        // callback function on success by geolocation.watchPosition
        function success(position) {
          const { latitude, longitude } = position.coords;
          locationUpdateCount++;
          console.log('Location updated:', latitude, longitude, '(Update #' + locationUpdateCount + ')');
          document.getElementById('updateCounter').textContent = locationUpdateCount;
          
          // Skip location updates and proximity checks while video is playing
          if (isVideoPlaying) {
            console.log('Video is playing - skipping location processing');
            return;
          }
          
          if (userMarker) {
            map.removeLayer(userMarker);
          }
          userMarker = L.marker([latitude, longitude]).addTo(map);
          
          // Only center the map on the first location update with higher zoom
          if (!hasInitiallycentered) {
            map.setView([latitude, longitude], 17);
            hasInitiallycentered = true;
          }
          
          checkProximity(latitude, longitude);
        }

        // callback function on error by geolocation.watchPosition
        function error(err) {
          switch(err.code) {
            case err.PERMISSION_DENIED:
              alert("User denied the request for Geolocation.");
              break;
            case err.POSITION_UNAVAILABLE:
              alert("Location information is unavailable.");
              break;
            case err.TIMEOUT:
              alert("The request to get user location timed out.");
              break;
            default:
              alert("An unknown error occurred.");
              break;
          }
          // Stop the geolocation watch listener on error
          if (watchId !== null) {
            navigator.geolocation.clearWatch(watchId);
            watchId = null; // Clear the watchId after stopping it
          }
        }
      }

      /**                       **/
      /**    GEOLOCATION API    **/
      /**                       **/
      /***************************/


      /***************************/
      /**                       **/
      /**    LOAD CONFIG API    **/
      /**                       **/

      // Step 5: Fetch videos.json file and load locations to map
      function fetchVideoLocations() {
        fetch('videos.json')
          .then((response) => {
            if (!response.ok) {
              throw new Error('Failed to load videos.json');
            }
            return response.json();
          })
          .then((data) => {
            videosData = data;
            console.log('Loaded video data:', videosData); // Log the fetched data
            addVideoLocationsToMap(); // Add locations to map only after data is fetched
          })
          .catch((error) => console.error('Error loading video locations:', error));
      }

      // Step 6: Add video location circles to the map
      function addVideoLocationsToMap() {
        videosData.forEach((video, index) => {
          const { latitude, longitude, radius, title, description } = video;

          // Check if latitude, longitude, and radius are defined and valid
          if (typeof latitude === 'number' && typeof longitude === 'number' && typeof radius === 'number') {
            const circle = L.circle([latitude, longitude], {
              color: 'red',
              radius: radius
            }).addTo(map);
            
            // Add popup with title and description if available
            const videoTitle = typeof title === 'object' ? (title[selectedLanguage] || title.en) : title;
            const videoDescription = typeof description === 'object' ? (description[selectedLanguage] || description.en) : description;
            
            if (videoTitle || videoDescription) {
              let popupContent = '';
              if (videoTitle) {
                popupContent += `<strong>${videoTitle}</strong>`;
              }
              if (videoDescription) {
                popupContent += videoTitle ? `<br>${videoDescription}` : videoDescription;
              }
              circle.bindPopup(popupContent);
              
              // Explicitly add tap event for mobile devices
              circle.on('click', function(e) {
                this.openPopup();
              });
              
              // Store circle and video data for later updates
              videoCircles.push({ circle, video });
            }
          } else {
            console.error(`Invalid data for video location at index ${index}:`, video);
          }
        });
      }

      /**                       **/
      /**    LOAD CONFIG API    **/
      /**                       **/
      /***************************/

      // Step 7: Check proximity to a video location and load video if in range
      function checkProximity(latitude, longitude) {
        let closestLocation = null;
        let closestDistance = Infinity;
        let inProximity = false; // Flag to track if user is within a video perimeter

        videosData.forEach((video) => {
          const distance = map.distance([latitude, longitude], [video.latitude, video.longitude]);
          if (distance <= video.radius) {
            inProximity = true; // User is inside a perimeter
            playVideo(video.videoUrl);
            distanceInfo.textContent = ''; // Clear distance info if inside a perimeter
          } else {
            if (distance < closestDistance) {
              closestDistance = distance;
              closestLocation = video;
            }
          }
        });

        // If user is outside all perimeters, show distance and direction to the closest location
        if (!inProximity && closestLocation) {
          const direction = calculateDirection(latitude, longitude, closestLocation.latitude, closestLocation.longitude);
          const distanceText = t('distanceText')
            .replace('{distance}', Math.round(closestDistance))
            .replace('{direction}', direction);
          distanceInfo.textContent = distanceText;
          stopVideo();
        }
      }

      // Step 9: Play video (handles delayed video loading)
      function playVideo(videoUrl) {
        const videoId = extractVideoId(videoUrl);
        if (isPlayerReady) {
          player.loadVideoById(videoId);
        } else {
          videoToLoad = videoUrl; // Queue video for later if player is not ready
        }
        videoContainer.style.display = 'block';// Ensure the video element is visible
      }

      // Stop video playback when user exits all defined areas
      function stopVideo() {
        if (player && typeof player.stopVideo === 'function') {
          player.stopVideo(); // Stop the video playback
        }
        videoContainer.style.display = 'none'; // Hide the video element
      }

      /***********************/
      /**                   **/
      /**    YOUTUBE API    **/
      /**                   **/

      // Step 8: Initialize YouTube IFrame API player
      function onYouTubeIframeAPIReady() {
        // Initialize the YouTube player
        player = new YT.Player('player', {
          height: '315',
          width: '100%',
          playerVars: { 'autoplay': 1, 'controls': 1 },
          events: {
            'onReady': onPlayerReady,
            'onError': onPlayerError,
            'onStateChange': onPlayerStateChange
          }
        });
      }

      var done = false;
      // call back function when youtube player status changed
      function onPlayerStateChange(event) {
        if (event.data == YT.PlayerState.PLAYING && !done) {
          isVideoPlaying = true;
          console.log('Video started playing - location updates paused');
          done = true;
        }
        if (event.data == PLAYER_ENDED) {
          isVideoPlaying = false;
          console.log('Video ended - resuming location updates');
          done = false;
        }
      }

      function getPlayerState(){
        if (player && typeof player.stopVideo === 'function') {
          return player.getPlayerState();
        }        
      }

      // call back function when youtube player is ready
      function onPlayerReady(event) {
        isPlayerReady = true;
        if (videoToLoad) {
          const videoId = extractVideoId(videoToLoad);
          console.log('Extracted video ID:', videoId);
          if (videoId && videoId.length === 11) {
            player.loadVideoById(videoId);
          } else {
            console.error('Invalid video ID:', videoToLoad);
          }
          videoToLoad = null; // Clear the queued video after loading
        }
      }

      // call back function when youtube player error occured
      function onPlayerError(event) {
        console.error('Error playing video:', event);
        alert('Failed to load the video. Please try again later.');
      }

      /**                   **/
      /**    YOUTUBE API    **/
      /**                   **/
      /***********************/


      // Utility function to calculate direction based on two sets of lat/lon coordinates
      function calculateDirection(lat1, lon1, lat2, lon2) {
        const rad = Math.PI / 180;
        const dLon = (lon2 - lon1) * rad;
        const y = Math.sin(dLon) * Math.cos(lat2 * rad);
        const x = Math.cos(lat1 * rad) * Math.sin(lat2 * rad) - Math.sin(lat1 * rad) * Math.cos(lat2 * rad) * Math.cos(dLon);
        const bearing = Math.atan2(y, x) * (180 / Math.PI);
        const compassDirections = ['North', 'North-East', 'East', 'South-East', 'South', 'South-West', 'West', 'North-West'];
        const compassIndex = Math.round(((bearing + 360) % 360) / 45) % 8;
        return compassDirections[compassIndex];
      }

      // Utility function to extract video ID from various YouTube URL formats
      function extractVideoId(url) {
          const videoIdMatch = url.match(/(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})/);
          return videoIdMatch ? videoIdMatch[1] : null; // Return the video ID if found
      }

    </script>
  </body>
</html>
